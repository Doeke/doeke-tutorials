import{d as w,r as M,o as D,a as P,c as U,b as F,p as V,t as I,e as L,f as B,F as N,g as G,h as O,i as X}from"./vendor.dd04fe14.js";const k=function(){const d=document.createElement("link").relList;if(d&&d.supports&&d.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))b(o);new MutationObserver(o=>{for(const s of o)if(s.type==="childList")for(const x of s.addedNodes)x.tagName==="LINK"&&x.rel==="modulepreload"&&b(x)}).observe(document,{childList:!0,subtree:!0});function m(o){const s={};return o.integrity&&(s.integrity=o.integrity),o.referrerpolicy&&(s.referrerPolicy=o.referrerpolicy),o.crossorigin==="use-credentials"?s.credentials="include":o.crossorigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function b(o){if(o.ep)return;o.ep=!0;const s=m(o);fetch(o.href,s)}};k();var Y="/doeke-tutorials/assets/logo.03d6d6da.png";const W=w({setup(A){const d=M();D(()=>{m(d.value)});function m(e){const t=e.getContext("webgl");if(!t){alert("Unable to initialize WebGL. Your browser or machine may not support it.");return}const c=C(t,`
    attribute vec4 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;

    varying highp vec2 vTextureCoord;

    void main(void) {
      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
      vTextureCoord = aTextureCoord;
    }
  `,`
    varying highp vec2 vTextureCoord;

    uniform sampler2D uSampler;

    void main(void) {
      gl_FragColor = texture2D(uSampler, vTextureCoord);
    }
  `),n={program:c,attribLocations:{vertexPosition:t.getAttribLocation(c,"aVertexPosition"),textureCoord:t.getAttribLocation(c,"aTextureCoord")},uniformLocations:{projectionMatrix:t.getUniformLocation(c,"uProjectionMatrix"),modelViewMatrix:t.getUniformLocation(c,"uModelViewMatrix"),uSampler:t.getUniformLocation(c,"uSampler")}},h=b(t),T=o(t,Y);var f=0;function p(u){u*=.001;const i=u-f;f=u,x(t,n,h,T,i,u),requestAnimationFrame(p)}requestAnimationFrame(p)}function b(e){const t=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,t);const a=[-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(a),e.STATIC_DRAW);const r=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,r);const c=[0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(c),e.STATIC_DRAW);const n=e.createBuffer();e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n);const h=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23];return e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Uint16Array(h),e.STATIC_DRAW),{position:t,textureCoord:r,indices:n}}function o(e,t){const a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);const r=0,c=e.RGBA,n=1,h=1,T=0,f=e.RGBA,p=e.UNSIGNED_BYTE,u=new Uint8Array([0,0,255,255]);e.texImage2D(e.TEXTURE_2D,r,c,n,h,T,f,p,u);const i=new Image;return i.onload=function(){e.bindTexture(e.TEXTURE_2D,a),e.texImage2D(e.TEXTURE_2D,r,c,f,p,i),s(i.width)&&s(i.height)?e.generateMipmap(e.TEXTURE_2D):(e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR))},i.src=t,a}function s(e){return(e&e-1)==0}function x(e,t,a,r,c,n){e.clearColor(0,0,0,1),e.clearDepth(1),e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT);const h=45*Math.PI/180,T=e.canvas.clientWidth/e.canvas.clientHeight,f=.1,p=100,u=F();V(u,h,T,f,p);const i=F();var S=n;I(i,i,[-0,0,-6]),L(i,i,S,[0,0,1]),L(i,i,S*.7,[0,1,0]);{const _=3,l=e.FLOAT,E=!1,v=0,R=0;e.bindBuffer(e.ARRAY_BUFFER,a.position),e.vertexAttribPointer(t.attribLocations.vertexPosition,_,l,E,v,R),e.enableVertexAttribArray(t.attribLocations.vertexPosition)}{const _=2,l=e.FLOAT,E=!1,v=0,R=0;e.bindBuffer(e.ARRAY_BUFFER,a.textureCoord),e.vertexAttribPointer(t.attribLocations.textureCoord,_,l,E,v,R),e.enableVertexAttribArray(t.attribLocations.textureCoord)}e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,a.indices),e.useProgram(t.program),e.uniformMatrix4fv(t.uniformLocations.projectionMatrix,!1,u),e.uniformMatrix4fv(t.uniformLocations.modelViewMatrix,!1,i),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,r),e.uniform1i(t.uniformLocations.uSampler,0);{const _=36,l=e.UNSIGNED_SHORT,E=0;e.drawElements(e.TRIANGLES,_,l,E)}}function C(e,t,a){const r=y(e,e.VERTEX_SHADER,t),c=y(e,e.FRAGMENT_SHADER,a),n=e.createProgram();return e.attachShader(n,r),e.attachShader(n,c),e.linkProgram(n),e.getProgramParameter(n,e.LINK_STATUS)?n:(alert("Unable to initialize the shader program: "+e.getProgramInfoLog(n)),null)}function y(e,t,a){const r=e.createShader(t);return e.shaderSource(r,a),e.compileShader(r),e.getShaderParameter(r,e.COMPILE_STATUS)?r:(alert("An error occurred compiling the shaders: "+e.getShaderInfoLog(r)),e.deleteShader(r),null)}return(e,t)=>(P(),U("canvas",{ref:(a,r)=>{r.canvas=a,d.value=a},width:"600",height:"400"},null,512))}}),z=G("h1",null,"Video Game Graphics: An Introduction",-1),j=O('<p> In this article we will take a short look into the world of programming video game graphics. I will talk about what is needed to draw a 3-dimensional cube like the one we see above, and afterwards you should be able to understand the source code for the example. The full code for this tutorial can be found on github. </p><h2>Vertex, vertices</h2><p> A point in 3d is called a vertex (plural: vertices) A vertex is defined as 3 coordinates: (X, Y, Z) </p><h2>Polygons</h2><p> - Everything can be drawn using only triangles - One triangle is made up of 3 points, or vertices - Each point has 3 coordinates (x, y, z) </p><h2>Central Processing Unit</h2><p> - The CPU is good at doing one complex task at a time - Every computer program you write is executed by the CPU, one line at a time - This works well for most things... but not for video game graphics - Video games need to draw each pixel on the screen many times per second - The CPU was too slow to draw pixels one by one </p><h2>Graphics Processing Unit</h2><p> - The GPU ( - cpu, ram, gpu and gpu memory </p><h2>Buffers</h2><p> - A buffer is a chunk of data in the GPU memory - This data can describe a list of vertices, </p><h2>Textures</h2><p></p><h2>Shader programs</h2><p></p><h2>Vertex shader</h2><p></p><h2>Fragment shader</h2><p></p><h2>Matrix / Matrices</h2><p> - A matrix is a short array of numbers that describes a rotation, translation - Dont worry about the details, leave that to the gl-matrix library - By describing the view position as a matrix we can move through environments </p><h2>Canvas Element</h2><p></p><p> Web pages are made out of elements for text, tables, images, etc. Originally, there was no way to draw triangles and pixels inside the web browser. Video games For this purpose, the &lt;canvas&gt; element was invented. Canvas is like a little screen inside a web page which can be given a width and height in pixels, and to which we can draw either 2d or 3d graphics. </p><p> The code for the cube example comes from the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL">Mozilla web tutorials</a>, an excellent resource for learning! </p>',25),H=w({setup(A){return(d,m)=>(P(),U(N,null,[z,B(W),j],64))}});const q={class:"App"},$=w({setup(A){return(d,m)=>(P(),U("div",q,[B(H)]))}});X($).mount("#app");
