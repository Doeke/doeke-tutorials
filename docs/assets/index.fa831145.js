import{d as U,r as B,o as M,a as P,c as y,b as F,p as G,t as D,e as L,f as g,F as k,g as I,h as N,i as V}from"./vendor.dd04fe14.js";const X=function(){const d=document.createElement("link").relList;if(d&&d.supports&&d.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))v(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const f of s.addedNodes)f.tagName==="LINK"&&f.rel==="modulepreload"&&v(f)}).observe(document,{childList:!0,subtree:!0});function l(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerpolicy&&(s.referrerPolicy=r.referrerpolicy),r.crossorigin==="use-credentials"?s.credentials="include":r.crossorigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function v(r){if(r.ep)return;r.ep=!0;const s=l(r);fetch(r.href,s)}};X();var O="/doeke-tutorials/assets/logo.03d6d6da.png";const W=U({setup(_){const d=B();M(()=>{l(d.value)});function l(e){const t=e.getContext("webgl");if(!t){alert("Unable to initialize WebGL. Your browser or machine may not support it.");return}const c=C(t,`
    attribute vec4 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;

    varying highp vec2 vTextureCoord;

    void main(void) {
      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
      vTextureCoord = aTextureCoord;
    }
  `,`
    varying highp vec2 vTextureCoord;

    uniform sampler2D uSampler;

    void main(void) {
      gl_FragColor = texture2D(uSampler, vTextureCoord);
    }
  `),i={program:c,attribLocations:{vertexPosition:t.getAttribLocation(c,"aVertexPosition"),textureCoord:t.getAttribLocation(c,"aTextureCoord")},uniformLocations:{projectionMatrix:t.getUniformLocation(c,"uProjectionMatrix"),modelViewMatrix:t.getUniformLocation(c,"uModelViewMatrix"),uSampler:t.getUniformLocation(c,"uSampler")}},u=v(t),T=r(t,O);var m=0;function p(h){h*=.001;const n=h-m;m=h,f(t,i,u,T,n,h),requestAnimationFrame(p)}requestAnimationFrame(p)}function v(e){const t=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,t);const a=[-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(a),e.STATIC_DRAW);const o=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,o);const c=[0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1];e.bufferData(e.ARRAY_BUFFER,new Float32Array(c),e.STATIC_DRAW);const i=e.createBuffer();e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,i);const u=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23];return e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Uint16Array(u),e.STATIC_DRAW),{position:t,textureCoord:o,indices:i}}function r(e,t){const a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);const o=0,c=e.RGBA,i=1,u=1,T=0,m=e.RGBA,p=e.UNSIGNED_BYTE,h=new Uint8Array([0,0,255,255]);e.texImage2D(e.TEXTURE_2D,o,c,i,u,T,m,p,h);const n=new Image;return n.onload=function(){e.bindTexture(e.TEXTURE_2D,a),e.texImage2D(e.TEXTURE_2D,o,c,m,p,n),s(n.width)&&s(n.height)?e.generateMipmap(e.TEXTURE_2D):(e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR))},n.src=t,a}function s(e){return(e&e-1)==0}function f(e,t,a,o,c,i){e.clearColor(0,0,0,1),e.clearDepth(1),e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT);const u=45*Math.PI/180,T=e.canvas.clientWidth/e.canvas.clientHeight,m=.1,p=100,h=F();G(h,u,T,m,p);const n=F();var S=i;D(n,n,[-0,0,-6]),L(n,n,S,[0,0,1]),L(n,n,S*.7,[0,1,0]);{const b=3,x=e.FLOAT,w=!1,E=0,A=0;e.bindBuffer(e.ARRAY_BUFFER,a.position),e.vertexAttribPointer(t.attribLocations.vertexPosition,b,x,w,E,A),e.enableVertexAttribArray(t.attribLocations.vertexPosition)}{const b=2,x=e.FLOAT,w=!1,E=0,A=0;e.bindBuffer(e.ARRAY_BUFFER,a.textureCoord),e.vertexAttribPointer(t.attribLocations.textureCoord,b,x,w,E,A),e.enableVertexAttribArray(t.attribLocations.textureCoord)}e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,a.indices),e.useProgram(t.program),e.uniformMatrix4fv(t.uniformLocations.projectionMatrix,!1,h),e.uniformMatrix4fv(t.uniformLocations.modelViewMatrix,!1,n),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,o),e.uniform1i(t.uniformLocations.uSampler,0);{const b=36,x=e.UNSIGNED_SHORT,w=0;e.drawElements(e.TRIANGLES,b,x,w)}}function C(e,t,a){const o=R(e,e.VERTEX_SHADER,t),c=R(e,e.FRAGMENT_SHADER,a),i=e.createProgram();return e.attachShader(i,o),e.attachShader(i,c),e.linkProgram(i),e.getProgramParameter(i,e.LINK_STATUS)?i:(alert("Unable to initialize the shader program: "+e.getProgramInfoLog(i)),null)}function R(e,t,a){const o=e.createShader(t);return e.shaderSource(o,a),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS)?o:(alert("An error occurred compiling the shaders: "+e.getShaderInfoLog(o)),e.deleteShader(o),null)}return(e,t)=>(P(),y("canvas",{ref:(a,o)=>{o.canvas=a,d.value=a},width:"600",height:"400"},null,512))}}),Y=I("h1",null,"Video Game Graphics: An Introduction",-1),q=N('<p> In this article we will take a short look into the world of programming video game graphics. I will talk about what is needed to draw a 3-dimensional cube like the one we see above, and afterwards you should be able to understand the source code for the example. The full code for this tutorial can be found on github: <a href="https://github.com/doeke/doeke-tutorials/">github.com/doeke-tutorials/</a></p><h2>Triangles</h2><p> In video game graphics, everything you see is actually made out of flat triangles, placed next to each other to give the illusion of complex shapes. This means that even the surface of objects like a cube or a sphere are approximated using multiple smaller triangles. These triangles are also called polygons, each corner of a polygon is called a vertex (plural: vertices). </p><p> To position a triangle in 3-dimensional space, we only have to describe the position of each of the three corners in X, Y, Z coordinates. Modern video games can create photo-realistic environments made up out of thousands of triangles! </p><h2>CPU - Central Processing Unit</h2><p> The CPU in a computer is good at executing series of complex tasks, one at a time. This is because that is how most computer programs are written, every line of code needs to be executed after the previous line has completed. This works great for almost anything... but not for video game graphics! </p><p> For video games, we need to draw our environment, often made out of thousands of triangles, to a screen, which can have millions of pixels, and we also need to do this many times per second to create a video-like experience! Drawing each pixel with the CPU, one by one, is out of the question, it would be way too slow! </p><h2>GPU - Graphics Processing Unit</h2><p> To solve this problem, the GPU was invented. Unlike a CPU, the GPU has a great number of smaller cores, each capable of drawing polygons and pixels independently of the other cores. In other words, they can draw on all the pixels of the screen, at the same time! </p><p> Great, that&#39;s one problem solved, but it created a new problem: How does our computer program, which is executed by the CPU, communicate with the GPU inside the computer? This is where graphics libraries like WebGL come in, using these we can tell the GPU exactly what we want it to draw. </p><h2>Buffers and textures</h2><p> All the data that a normal computer program needs to work with, is stored inside computer memory, which is linked to the CPU. However, the data that the GPU needs, such as images and information about the triangles, needs to be stored inside the GPU&#39;s own memory rather than in CPU memory. The reason for this again has to do with performance (speed), for the GPU it is much faster to have its own memory chip close by. </p><p> The downside of this is that triangle and image data will first need to be copied to the GPU memory before we can draw the game. This is what happens during video game loading screens, the user has to wait while we copy all this data to the GPU memory! Number data like triangle positions are called &quot;buffers&quot; when they&#39;re stored in GPU memory, and images like the Vue logo in the example are called &quot;textures&quot;. </p><h2>Shader programs</h2><p> Shader programs are small programs written in a computer language made specifically for the GPU. The two main parts of a shader program are called the vertex shader and the fragment shader. </p><p> The vertex shader tells the GPU where on the screen each corner of every triangle should be placed. This changes every time the object that the triangle is a part of moves or rotates, and also when the player changes the direction in which they look. The fragment shader is responsible for telling the GPU what the final color of each pixel on the screen will be, based on the information about the triangle that occupies that place on the screen. </p><h2>Canvas Element</h2><p> Web pages are made out of elements for text, tables, images, etc. It used to be impossible to draw 3-dimensional triangles and pixels from inside the web browser. </p><p> For this purpose, the &lt;canvas&gt; element was invented. The canvas element is like a smaller screen inside a web page which can be given a width and height in pixels, and to which we can draw either 2d or 3d graphics. </p><h2>Finally</h2><p> Thanks for reading! If you have any questions, don&#39;t hesitate to ask. I had to leave out a lot of details, if there is interest I can make a sequel. </p><p> The code for the cube example comes from the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL">Mozilla web tutorials</a>, an excellent resource for learning! </p>',22),j=U({setup(_){return(d,l)=>(P(),y(k,null,[Y,g(W),q],64))}});const z={class:"App"},H=U({setup(_){return(d,l)=>(P(),y("div",z,[g(j)]))}});V(H).mount("#app");
